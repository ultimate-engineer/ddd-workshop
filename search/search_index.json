{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About this workshop This workshop will unravel DDD into practical actions when developing Java solutions. We'll cover both strategy and tactics: We'll start a solution case from scratch and cover how several concepts, such as bounded context, context maps, and ubiquitous language, can be used efficiently. See why and how these practices can increase the chances of delivering a solution that correctly maps down different business needs and allows us to develop the best implementation strategies to reflect a business problem into a technical solution. While getting our hands dirty in coding, we'll learn patterns such as entity, value object, repository, and aggregator, applied to Java.","title":"About this workshop"},{"location":"#about-this-workshop","text":"This workshop will unravel DDD into practical actions when developing Java solutions. We'll cover both strategy and tactics: We'll start a solution case from scratch and cover how several concepts, such as bounded context, context maps, and ubiquitous language, can be used efficiently. See why and how these practices can increase the chances of delivering a solution that correctly maps down different business needs and allows us to develop the best implementation strategies to reflect a business problem into a technical solution. While getting our hands dirty in coding, we'll learn patterns such as entity, value object, repository, and aggregator, applied to Java.","title":"About this workshop"},{"location":"00_environment/","text":"Preparing your environment Most of the workshop exercises involves usage of tools such as: - Developer IDE (e.g. VSCode, Eclipse, IntelliJ, ...) - Egon.io - CLI tools via terminal Prerequisites Maven CLI; Git CLI; Java 17; An IDE of your preference; Command line (terminal). If using Windows, PowerShell is recommended; REST client tools like cURL or postman (Optional) ; java -version mvn -version git --version To validate your environment, confirm you have as an output of the commands above working: $ java -version openjdk version \"17.0.6\" 2023 -01-17 OpenJDK Runtime Environment Temurin-17.0.6+10 ( build 17 .0.6+10 ) OpenJDK 64 -Bit Server VM Temurin-17.0.6+10 ( build 17 .0.6+10, mixed mode ) $ mvn -version Apache Maven 3 .9.0 ( 9b58d2bad23a66be161c4664ef21ce219c2c8584 ) Maven home: /opt/homebrew/Cellar/maven/3.9.0/libexec Java version: 19 .0.2, vendor: Homebrew, runtime: /opt/homebrew/Cellar/openjdk/19.0.2/libexec/openjdk.jdk/Contents/Home Default locale: en_BR, platform encoding: UTF-8 OS name: \"mac os x\" , version: \"13.0.1\" , arch: \"aarch64\" , family: \"mac\" $ git --version git version 2 .37.1 ( Apple Git-137.1 ) Prepare your working directory To get started with the labs, first you need to clone the projects used in the exercises and have it available in your local development environment. Info The guided exercises are built on top of quickstart projects, a foundation set of preconfigured projects. To get the foundation projects and build them, execute: git clone https://github.com/ultimate-engineer/ddd-workshop-labs cd ddd-workshop-labs mvn clean package The build and packaging should complete successfully. Using Egon for Domain Modeling In this workshop, you will use Egon.io to model the domain and its elements throughout the exercises. Throughout the exercises, you will handle different use cases in different domains. Each domain is represented in a different diagram. During the exercises, you'll be instructed to import the respective diagram files in Egon. The file ends with . dst extension, and once imported, you'll have in Egon preconfigured diagram with icons and elements settings. (Optional) Extra icons and configurations The workshop uses extra icons not available by default in the tool. In case you want to add extra icons or change the icon's type (e.g. from Actor to WorkObject ) you can do that in the tool's settings. See details below: Using your browser, navigate to https://egon.io/app/ In the top-right corner, click on the Settings icon; Now, you can upload the icons of our domain: Click on the \"Upload Custom Icons\" button; Locate the ddd-workshop-labs project you have cloned on the previous step. Select and upload your custom icon, or all icons located in the directory: ddd-workshop-labs/storytelling/icons Now, upload the icons settings. Each icon can be configured to be used as an actor or a work object . These settings are already configured for you. Click on the \"import icon configuration\" icon: Save your configurations.","title":"Preparing your environment"},{"location":"00_environment/#preparing-your-environment","text":"Most of the workshop exercises involves usage of tools such as: - Developer IDE (e.g. VSCode, Eclipse, IntelliJ, ...) - Egon.io - CLI tools via terminal","title":"Preparing your environment"},{"location":"00_environment/#prerequisites","text":"Maven CLI; Git CLI; Java 17; An IDE of your preference; Command line (terminal). If using Windows, PowerShell is recommended; REST client tools like cURL or postman (Optional) ; java -version mvn -version git --version To validate your environment, confirm you have as an output of the commands above working: $ java -version openjdk version \"17.0.6\" 2023 -01-17 OpenJDK Runtime Environment Temurin-17.0.6+10 ( build 17 .0.6+10 ) OpenJDK 64 -Bit Server VM Temurin-17.0.6+10 ( build 17 .0.6+10, mixed mode ) $ mvn -version Apache Maven 3 .9.0 ( 9b58d2bad23a66be161c4664ef21ce219c2c8584 ) Maven home: /opt/homebrew/Cellar/maven/3.9.0/libexec Java version: 19 .0.2, vendor: Homebrew, runtime: /opt/homebrew/Cellar/openjdk/19.0.2/libexec/openjdk.jdk/Contents/Home Default locale: en_BR, platform encoding: UTF-8 OS name: \"mac os x\" , version: \"13.0.1\" , arch: \"aarch64\" , family: \"mac\" $ git --version git version 2 .37.1 ( Apple Git-137.1 )","title":"Prerequisites"},{"location":"00_environment/#prepare-your-working-directory","text":"To get started with the labs, first you need to clone the projects used in the exercises and have it available in your local development environment. Info The guided exercises are built on top of quickstart projects, a foundation set of preconfigured projects. To get the foundation projects and build them, execute: git clone https://github.com/ultimate-engineer/ddd-workshop-labs cd ddd-workshop-labs mvn clean package The build and packaging should complete successfully.","title":"Prepare your working directory"},{"location":"00_environment/#using-egon-for-domain-modeling","text":"In this workshop, you will use Egon.io to model the domain and its elements throughout the exercises. Throughout the exercises, you will handle different use cases in different domains. Each domain is represented in a different diagram. During the exercises, you'll be instructed to import the respective diagram files in Egon. The file ends with . dst extension, and once imported, you'll have in Egon preconfigured diagram with icons and elements settings.","title":"Using Egon for Domain Modeling"},{"location":"00_environment/#optional-extra-icons-and-configurations","text":"The workshop uses extra icons not available by default in the tool. In case you want to add extra icons or change the icon's type (e.g. from Actor to WorkObject ) you can do that in the tool's settings. See details below: Using your browser, navigate to https://egon.io/app/ In the top-right corner, click on the Settings icon; Now, you can upload the icons of our domain: Click on the \"Upload Custom Icons\" button; Locate the ddd-workshop-labs project you have cloned on the previous step. Select and upload your custom icon, or all icons located in the directory: ddd-workshop-labs/storytelling/icons Now, upload the icons settings. Each icon can be configured to be used as an actor or a work object . These settings are already configured for you. Click on the \"import icon configuration\" icon: Save your configurations.","title":"(Optional) Extra icons and configurations"},{"location":"01_action/","text":"1st Action, the Bookstore: Getting Started with Domain Storytelling Using Domain Storytelling we will: explore a business problem and goal, describe a domain and understand how this is the first step into designing the respective Java solution. Understand the problem being solved and map it using Egon; Identify four core elements: actors , work objects , activities and sequence numbers . Watch and learn It's time to join the instructor and get action! Learn while supporting and discussing with your group and instructor. Scenario Business Goal: A customer visits a bookstore and buys the desired book. Designing a Java service based on the Domain Storytelling In this instructor-led interactive practice, learn how the previous practice facilitates: the use case understanding scenario documentation domain language mapping Software design Follow along and contribute in a live coding session with your instructor;","title":"1st Action, the Bookstore: Getting Started with Domain Storytelling"},{"location":"01_action/#1st-action-the-bookstore-getting-started-with-domain-storytelling","text":"Using Domain Storytelling we will: explore a business problem and goal, describe a domain and understand how this is the first step into designing the respective Java solution. Understand the problem being solved and map it using Egon; Identify four core elements: actors , work objects , activities and sequence numbers . Watch and learn It's time to join the instructor and get action! Learn while supporting and discussing with your group and instructor.","title":"1st Action, the Bookstore: Getting Started with Domain Storytelling"},{"location":"01_action/#scenario","text":"Business Goal: A customer visits a bookstore and buys the desired book.","title":"Scenario"},{"location":"01_action/#designing-a-java-service-based-on-the-domain-storytelling","text":"In this instructor-led interactive practice, learn how the previous practice facilitates: the use case understanding scenario documentation domain language mapping Software design Follow along and contribute in a live coding session with your instructor;","title":"Designing a Java service based on the Domain Storytelling"},{"location":"02_action/","text":"2nd Action, the Taxi: a Domain Storytelling exercise In this exercise you can validate and practice your knowledge of the following concepts: Mapping interaction between multiple Actors ; Multiple Work Objects used through several actions ordered and mapped with associations ; Model the service using the domain storytelling as the source of knowledge; Roll up your sleeves, and get to action! It's time to practice what you have learned and get your hands. Roll up your sleeves and let's get to action! Exercise goals In this practice, you'll have three tasks: 1. Understanding the business need and, 2. Mapping the domain components using Domain Storytelling; Map the main Actor Map expected Actions taken by the actors Number the order in which these actions happen Map any objects the elements involved Track the Domain Language 3. Design a Java service using your discoveries. Design and create a Java project based on the Domain Storytelling. Use the domain language Scenario Business Goal: A passenger can go to a destination, by taxi, and pay the drive accordingly. Practicing Domain Storytelling Now, explore the use case asking the business person at hand ( chosen by the instructor ) about how this user story. Use Egon to map the domain elements. The outcome of this practice should be a diagram representation of the Taxi use case. Getting Started It's time to start our Domain Storytelling mapping. You can either start from scratch or use a partial implementation to help you get started. TIP: Shedding light on solutions Start by mapping the actors of the domain. How many Actors are involved? Who are these Actors ? Describe the elements,the Work Objects of the story. Items such as Destination , Taxi , Fare , and Taximeters are examples of Work Objects in this domain. Don't forget to add the sequence numbers to clarify how this story's actions flow. Using your browser, access Egon.io Import the diagram located under ddd-workshop-labs/storytelling/02-taxi.dst Complete the domain by exploring the use case, asking questions or discussing with other attendees; Once you're satisfied with the domain map, and you feel like it covers the use case story accordingly, you are ready to start designing you Java service. Our next step is to practice the modeling of the application, matching the implementation with the domain exploration details. A Story becomes Code: Creating the Java service In the ddd-workshop-labs folder, locate and open the project 02-taxi using your chosen Java IDE; Create the Java entities required by your use case - your implementation should match your domain model. The models can be created under 02-taxi/src/main/java/expert/os/workshop/ddd/taxi Unit tests, can be created under 02-taxi/src/test/java/expert/os/workshop/ddd/taxi Here are some examples and ideas to help you get started: * The domain diagram describes entities we can model. Examples: Passenger , Driver , Ride , Taximeter and Car . * These entities relate to each other, and the model's actions can actually become methods and associations between these classes. * For example, a Passenger , has many Rides ; * It should be possible to set a destination of a Ride ; * The Taximeter can be used by the Driver to flag the ride as economic or expensive. The unit tests can help you validate if your code is behaving as you expect. The Test class is pretty simple and helpful on the developement process. Below is an example of a test class - remember that story's interpretation are unique, therefore, your implementation is also unique!; package expert.os.workshop.ddd.taxi ; import org.assertj.core.api.Assertions ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; import javax.money.MonetaryAmount ; import java.time.LocalTime ; import static expert.os.workshop.ddd.taxi.Taximeter.ECONOMIC ; import static expert.os.workshop.ddd.taxi.Taximeter.EXPENSIVE ; import static org.junit.jupiter.api.Assertions.* ; class TaximeterTest { private Taximeter taximeter ; @BeforeEach public void setUp () { this . taximeter = new Taximeter (); } @Test public void shouldUseEconomicFlag () { LocalTime time = LocalTime . of ( 9 , 0 ); Ride economic = new Ride ( \"Aiport\" , \"house\" , 1 , time ); MonetaryAmount amount = taximeter . fare ( economic ); Assertions . assertThat ( amount ). isNotNull (). isEqualTo ( ECONOMIC ); } } These insights should help you understand what are the expected classes to have, methods and associations.","title":"2nd Action, the Taxi: a Domain Storytelling exercise"},{"location":"02_action/#2nd-action-the-taxi-a-domain-storytelling-exercise","text":"In this exercise you can validate and practice your knowledge of the following concepts: Mapping interaction between multiple Actors ; Multiple Work Objects used through several actions ordered and mapped with associations ; Model the service using the domain storytelling as the source of knowledge; Roll up your sleeves, and get to action! It's time to practice what you have learned and get your hands. Roll up your sleeves and let's get to action!","title":"2nd Action, the Taxi: a Domain Storytelling exercise"},{"location":"02_action/#exercise-goals","text":"In this practice, you'll have three tasks: 1. Understanding the business need and, 2. Mapping the domain components using Domain Storytelling; Map the main Actor Map expected Actions taken by the actors Number the order in which these actions happen Map any objects the elements involved Track the Domain Language 3. Design a Java service using your discoveries. Design and create a Java project based on the Domain Storytelling. Use the domain language","title":"Exercise goals"},{"location":"02_action/#scenario","text":"Business Goal: A passenger can go to a destination, by taxi, and pay the drive accordingly.","title":"Scenario"},{"location":"02_action/#practicing-domain-storytelling","text":"Now, explore the use case asking the business person at hand ( chosen by the instructor ) about how this user story. Use Egon to map the domain elements. The outcome of this practice should be a diagram representation of the Taxi use case.","title":"Practicing Domain Storytelling"},{"location":"02_action/#getting-started","text":"It's time to start our Domain Storytelling mapping. You can either start from scratch or use a partial implementation to help you get started. TIP: Shedding light on solutions Start by mapping the actors of the domain. How many Actors are involved? Who are these Actors ? Describe the elements,the Work Objects of the story. Items such as Destination , Taxi , Fare , and Taximeters are examples of Work Objects in this domain. Don't forget to add the sequence numbers to clarify how this story's actions flow. Using your browser, access Egon.io Import the diagram located under ddd-workshop-labs/storytelling/02-taxi.dst Complete the domain by exploring the use case, asking questions or discussing with other attendees; Once you're satisfied with the domain map, and you feel like it covers the use case story accordingly, you are ready to start designing you Java service. Our next step is to practice the modeling of the application, matching the implementation with the domain exploration details.","title":"Getting Started"},{"location":"02_action/#a-story-becomes-code-creating-the-java-service","text":"In the ddd-workshop-labs folder, locate and open the project 02-taxi using your chosen Java IDE; Create the Java entities required by your use case - your implementation should match your domain model. The models can be created under 02-taxi/src/main/java/expert/os/workshop/ddd/taxi Unit tests, can be created under 02-taxi/src/test/java/expert/os/workshop/ddd/taxi Here are some examples and ideas to help you get started: * The domain diagram describes entities we can model. Examples: Passenger , Driver , Ride , Taximeter and Car . * These entities relate to each other, and the model's actions can actually become methods and associations between these classes. * For example, a Passenger , has many Rides ; * It should be possible to set a destination of a Ride ; * The Taximeter can be used by the Driver to flag the ride as economic or expensive. The unit tests can help you validate if your code is behaving as you expect. The Test class is pretty simple and helpful on the developement process. Below is an example of a test class - remember that story's interpretation are unique, therefore, your implementation is also unique!; package expert.os.workshop.ddd.taxi ; import org.assertj.core.api.Assertions ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; import javax.money.MonetaryAmount ; import java.time.LocalTime ; import static expert.os.workshop.ddd.taxi.Taximeter.ECONOMIC ; import static expert.os.workshop.ddd.taxi.Taximeter.EXPENSIVE ; import static org.junit.jupiter.api.Assertions.* ; class TaximeterTest { private Taximeter taximeter ; @BeforeEach public void setUp () { this . taximeter = new Taximeter (); } @Test public void shouldUseEconomicFlag () { LocalTime time = LocalTime . of ( 9 , 0 ); Ride economic = new Ride ( \"Aiport\" , \"house\" , 1 , time ); MonetaryAmount amount = taximeter . fare ( economic ); Assertions . assertThat ( amount ). isNotNull (). isEqualTo ( ECONOMIC ); } } These insights should help you understand what are the expected classes to have, methods and associations.","title":"A Story becomes Code: Creating the Java service"},{"location":"03_action/","text":"3rd Action, the Movie: Establishing Boundaries and Context Mapping In this exercise you will see how the concepts of bounded context and context mapping can be applied in real life. Roll up your sleeves, and get to action! It's time to practice what you have learned and get your hands. Roll up your sleeves and let's get to action! Exercise goals Fix and Complete the domain storytelling diagram; As a developer, explore the existing project and evaluate implementation choices; Implement one missing need described in the diagram, in the application; Scenario Business Goal: As a moviegoer, I want to go to the movie theater, buy a ticket, maybe get some snacks and drinks, and watch the chosen movie. Practicing Domain Storytelling Use Egon to map this story while you explore it using Domain Storytelling. The outcome of this practice should be a diagram representation of the Movie use case and its respective java service . Getting Started Using your browser, access Egon.io Import the diagram located under ddd-workshop-labs/storytelling/03-movies.dst It should look like this: Complete the domain by exploring the use case, asking questions or discussing with other attendees; Make sure you complete the following tasks: Some actions are certainly missing in this diagram. Which actions should be mapped for the moviegoer that are not represented? Describe in the diagram, the sequence order of each action. To change a group sequence, you can double-click on the association arrow and set your input data; Are there optional items? Add a text annotation to highlight this characteristic. Once you're satisfied with the domain map, and you feel like it covers the use case story accordingly, you are ready to start designing you Java service. Our next step is to practice the modeling of the application, matching the implementation with the domain exploration details. From Story to Code: the Movie service In the ddd-workshop-labs folder, locate and open the project 03-cinema using your chosen Java IDE; Observe and learn Open the test class expert.os.workshop.ddd.cinema.OrderTest ; Now evaluate the following items: Is this test is validating the user story previously described? If not, what are your ideas to adjust it? In this unit test, we can notice the following validation: 1 2 3 4 5 6 7 8 9 10 11 Movie movie = new Movie ( \"Matrix\" , Year . of ( 1999 )); //(1) Product ticket = new Ticket ( movie , Money . of ( 10 , currency )); //(2) Product popcorn = new Food ( \"popcorn\" , Money . of ( 15 , currency )); //(3) Order order = Order . of ( moviegoer ); //(4) order . add ( ticket ); order . add ( popcorn ); //(5)! MonetaryAmount total = order . total (); //(6) Assertions . assertThat ( total ) . isEqualTo ( Money . of ( 25 , currency )); //(7) Creates the Movie Matrix, from 1999; The Ticket for this Movie costs $10; The Food available to be bought is a popcorn, and it costs $15; The Moviegoer creates a new order; This person's Order includes a Ticket for Matrix and his snack, the popcorn. The Moviegoer needs to pay for the total amount of this order; Assures the total Order cost is compliant to the business rules; The test validates one of the paths of our storytelling: a user should be able to acquire movie theater tickets and snacks in order to watch the movie. Due to the domain exploration, you probably feel comfortable when reading this text - a result of the usage of ubiquitous language across business conversations and the technology scope. Now, before finishing this project's implementation, navigate through the project and notice the following details: Entities such as Moviegoer and Movie are mapped with org.jmolecules.ddd.annotation.@Entity . How can this class setting be helpful? The products sold by this movie theater are defined by the Interface named Product . public record Food ( String name , MonetaryAmount price ) implements Product {} public record Ticket ( Movie movie , MonetaryAmount price ) implements Product { } Because we're relying on OOP abstraction, in the Order class, adding a new product is really simple to write, understand and maintain: 1 2 3 4 public void add ( Product product ) { //(1) Objects . requireNonNull ( product , \"product is required\" ); this . products . add ( product ); } If new products are made available, the impacts on the Order class should be minimal to none; Testing the Movie Service Now, make sure your project is working just fine. Using your IDE or your terminal, run the following command: mvn clean package You should see one test executed successfully, as well as the project build. ------------------------------------------------------- [ INFO ] Running expert.os.workshop.ddd.cinema.OrderTest Mar 21 , 2023 7 :39:08 PM org.javamoney.moneta.DefaultMonetaryContextFactory createMonetaryContextNonNullConfig INFO: Using custom MathContext: precision = 256 , roundingMode = HALF_EVEN [ INFO ] Tests run: 1 , Failures: 0 , Errors: 0 , Skipped: 0 , Time elapsed: 0 .067 s - in expert.os.workshop.ddd.cinema.OrderTest [ INFO ] [ INFO ] Results: [ INFO ] [ INFO ] Tests run: 1 , Failures: 0 , Errors: 0 , Skipped: 0 [ INFO ] [ INFO ] ------------------------------------------------------------------------ [ INFO ] BUILD SUCCESS [ INFO ] ------------------------------------------------------------------------ [ INFO ] Total time: 1 .407 s [ INFO ] Finished at: 2023 -03-21T19:39:09-03:00 [ INFO ] ------------------------------------------------------------------------ Now, let's expand our implementation and certify the benefits of the Domain Storytelling practice and an application designed and developed through DDD principles. Expanding the implementation Now, as a developer who recently joined the team, you've learned about the use case through the Domain Storytelling practice. Next step: choosing the next implementation At this stage, having looked at the domain diagram and existing code, do you feel comfortable when asked to identify which features are still missing and choosing one to implement? For example. As of now, the Movie Service provides the following capability: A Moviegoer registers an Order containing a Ticket and Food , and is informed the total cost; Can you identify more scenarios to be implemented, based on the diagram 03-movies ? Now, let's go back to coding. Next step: choosing the next implementation Choose one of the discussed scenarios to implement in the 03-movie application; Use as much as you can, the terminology described in the domain diagram; Implement a unit test to confirm your solution is working. If you need some help, next is some guidance to support you on this task. If you feel comfortable, we recommend you to try to identify and add the next enhancement based on your interpretation and coding only. Enhancement: Allow customers to buy beverages As of now, we only support orders with Food . Let's add the Beverage to our solution. Let's start with the unit test, as stated by TDD (Test Driven Development) practices. Open the test.java.expert.os.workshop.ddd.cinema.OrderTest class; Add a new unit test called shouldSumTotalWithBeverage ; Don't forget the \" @Test \" annotation. The test can look like this: 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @Test public void shouldTotalWithBeverage () { Movie movie = new Movie ( \"Avatar\" , Year . of ( 2022 )); Product ticket = new Ticket ( movie , Money . of ( 10 , currency )); Product popcorn = new Food ( \"popcorn\" , Money . of ( 15 , currency )); Product soda = new Beverage ( \"soda\" , Money . of ( 5 , currency )); //(1) Order order = Order . of ( moviegoer ); order . add ( ticket ); order . add ( popcorn ); order . add ( soda ); //(2) MonetaryAmount total = order . total (); Assertions . assertThat ( total ) . isEqualTo ( Money . of ( 30 , currency )); //(3) } Creates a new beverage abstrated as a product Adds the beverage \"soda\" to the order; Asserts that the total now includes the beverage cost; Adding the beverage model Now, your application is breaking, as expected. It's time to create the entity Beverage . In the package expert.os.workshop.ddd.cinema , create a new class called Beverage.java . It can look as the sample below. Notice we can rely on the Product interface to garantee it will behave as expecteed for a Product in this domain. package expert.os.workshop.ddd.cinema ; import javax.money.MonetaryAmount ; public record Beverage ( String name , MonetaryAmount price ) implements Product { } Using your IDE or a command line, run the maven test and check the resulting output. mvn clean test Did it work? Why did the price was correctly calculated even though we didn't add new business logic to the order? Congratulations! You've done a great job so far. Let's keep on adding new concepts and technologies to our exercises.","title":"3rd Action, the Movie: Establishing Boundaries and Context Mapping"},{"location":"03_action/#3rd-action-the-movie-establishing-boundaries-and-context-mapping","text":"In this exercise you will see how the concepts of bounded context and context mapping can be applied in real life. Roll up your sleeves, and get to action! It's time to practice what you have learned and get your hands. Roll up your sleeves and let's get to action!","title":"3rd Action, the Movie: Establishing Boundaries and Context Mapping"},{"location":"03_action/#exercise-goals","text":"Fix and Complete the domain storytelling diagram; As a developer, explore the existing project and evaluate implementation choices; Implement one missing need described in the diagram, in the application;","title":"Exercise goals"},{"location":"03_action/#scenario","text":"Business Goal: As a moviegoer, I want to go to the movie theater, buy a ticket, maybe get some snacks and drinks, and watch the chosen movie.","title":"Scenario"},{"location":"03_action/#practicing-domain-storytelling","text":"Use Egon to map this story while you explore it using Domain Storytelling. The outcome of this practice should be a diagram representation of the Movie use case and its respective java service .","title":"Practicing Domain Storytelling"},{"location":"03_action/#getting-started","text":"Using your browser, access Egon.io Import the diagram located under ddd-workshop-labs/storytelling/03-movies.dst It should look like this: Complete the domain by exploring the use case, asking questions or discussing with other attendees; Make sure you complete the following tasks: Some actions are certainly missing in this diagram. Which actions should be mapped for the moviegoer that are not represented? Describe in the diagram, the sequence order of each action. To change a group sequence, you can double-click on the association arrow and set your input data; Are there optional items? Add a text annotation to highlight this characteristic. Once you're satisfied with the domain map, and you feel like it covers the use case story accordingly, you are ready to start designing you Java service. Our next step is to practice the modeling of the application, matching the implementation with the domain exploration details.","title":"Getting Started"},{"location":"03_action/#from-story-to-code-the-movie-service","text":"In the ddd-workshop-labs folder, locate and open the project 03-cinema using your chosen Java IDE;","title":"From Story to Code: the Movie service"},{"location":"03_action/#observe-and-learn","text":"Open the test class expert.os.workshop.ddd.cinema.OrderTest ; Now evaluate the following items: Is this test is validating the user story previously described? If not, what are your ideas to adjust it? In this unit test, we can notice the following validation: 1 2 3 4 5 6 7 8 9 10 11 Movie movie = new Movie ( \"Matrix\" , Year . of ( 1999 )); //(1) Product ticket = new Ticket ( movie , Money . of ( 10 , currency )); //(2) Product popcorn = new Food ( \"popcorn\" , Money . of ( 15 , currency )); //(3) Order order = Order . of ( moviegoer ); //(4) order . add ( ticket ); order . add ( popcorn ); //(5)! MonetaryAmount total = order . total (); //(6) Assertions . assertThat ( total ) . isEqualTo ( Money . of ( 25 , currency )); //(7) Creates the Movie Matrix, from 1999; The Ticket for this Movie costs $10; The Food available to be bought is a popcorn, and it costs $15; The Moviegoer creates a new order; This person's Order includes a Ticket for Matrix and his snack, the popcorn. The Moviegoer needs to pay for the total amount of this order; Assures the total Order cost is compliant to the business rules; The test validates one of the paths of our storytelling: a user should be able to acquire movie theater tickets and snacks in order to watch the movie. Due to the domain exploration, you probably feel comfortable when reading this text - a result of the usage of ubiquitous language across business conversations and the technology scope. Now, before finishing this project's implementation, navigate through the project and notice the following details: Entities such as Moviegoer and Movie are mapped with org.jmolecules.ddd.annotation.@Entity . How can this class setting be helpful? The products sold by this movie theater are defined by the Interface named Product . public record Food ( String name , MonetaryAmount price ) implements Product {} public record Ticket ( Movie movie , MonetaryAmount price ) implements Product { } Because we're relying on OOP abstraction, in the Order class, adding a new product is really simple to write, understand and maintain: 1 2 3 4 public void add ( Product product ) { //(1) Objects . requireNonNull ( product , \"product is required\" ); this . products . add ( product ); } If new products are made available, the impacts on the Order class should be minimal to none;","title":"Observe and learn"},{"location":"03_action/#testing-the-movie-service","text":"Now, make sure your project is working just fine. Using your IDE or your terminal, run the following command: mvn clean package You should see one test executed successfully, as well as the project build. ------------------------------------------------------- [ INFO ] Running expert.os.workshop.ddd.cinema.OrderTest Mar 21 , 2023 7 :39:08 PM org.javamoney.moneta.DefaultMonetaryContextFactory createMonetaryContextNonNullConfig INFO: Using custom MathContext: precision = 256 , roundingMode = HALF_EVEN [ INFO ] Tests run: 1 , Failures: 0 , Errors: 0 , Skipped: 0 , Time elapsed: 0 .067 s - in expert.os.workshop.ddd.cinema.OrderTest [ INFO ] [ INFO ] Results: [ INFO ] [ INFO ] Tests run: 1 , Failures: 0 , Errors: 0 , Skipped: 0 [ INFO ] [ INFO ] ------------------------------------------------------------------------ [ INFO ] BUILD SUCCESS [ INFO ] ------------------------------------------------------------------------ [ INFO ] Total time: 1 .407 s [ INFO ] Finished at: 2023 -03-21T19:39:09-03:00 [ INFO ] ------------------------------------------------------------------------ Now, let's expand our implementation and certify the benefits of the Domain Storytelling practice and an application designed and developed through DDD principles.","title":"Testing the Movie Service"},{"location":"03_action/#expanding-the-implementation","text":"Now, as a developer who recently joined the team, you've learned about the use case through the Domain Storytelling practice.","title":"Expanding the implementation"},{"location":"03_action/#next-step-choosing-the-next-implementation","text":"At this stage, having looked at the domain diagram and existing code, do you feel comfortable when asked to identify which features are still missing and choosing one to implement? For example. As of now, the Movie Service provides the following capability: A Moviegoer registers an Order containing a Ticket and Food , and is informed the total cost; Can you identify more scenarios to be implemented, based on the diagram 03-movies ? Now, let's go back to coding.","title":"Next step: choosing the next implementation"},{"location":"03_action/#next-step-choosing-the-next-implementation_1","text":"Choose one of the discussed scenarios to implement in the 03-movie application; Use as much as you can, the terminology described in the domain diagram; Implement a unit test to confirm your solution is working. If you need some help, next is some guidance to support you on this task. If you feel comfortable, we recommend you to try to identify and add the next enhancement based on your interpretation and coding only.","title":"Next step: choosing the next implementation"},{"location":"03_action/#enhancement-allow-customers-to-buy-beverages","text":"As of now, we only support orders with Food . Let's add the Beverage to our solution. Let's start with the unit test, as stated by TDD (Test Driven Development) practices. Open the test.java.expert.os.workshop.ddd.cinema.OrderTest class; Add a new unit test called shouldSumTotalWithBeverage ; Don't forget the \" @Test \" annotation. The test can look like this: 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @Test public void shouldTotalWithBeverage () { Movie movie = new Movie ( \"Avatar\" , Year . of ( 2022 )); Product ticket = new Ticket ( movie , Money . of ( 10 , currency )); Product popcorn = new Food ( \"popcorn\" , Money . of ( 15 , currency )); Product soda = new Beverage ( \"soda\" , Money . of ( 5 , currency )); //(1) Order order = Order . of ( moviegoer ); order . add ( ticket ); order . add ( popcorn ); order . add ( soda ); //(2) MonetaryAmount total = order . total (); Assertions . assertThat ( total ) . isEqualTo ( Money . of ( 30 , currency )); //(3) } Creates a new beverage abstrated as a product Adds the beverage \"soda\" to the order; Asserts that the total now includes the beverage cost;","title":"Enhancement: Allow customers to buy beverages"},{"location":"03_action/#adding-the-beverage-model","text":"Now, your application is breaking, as expected. It's time to create the entity Beverage . In the package expert.os.workshop.ddd.cinema , create a new class called Beverage.java . It can look as the sample below. Notice we can rely on the Product interface to garantee it will behave as expecteed for a Product in this domain. package expert.os.workshop.ddd.cinema ; import javax.money.MonetaryAmount ; public record Beverage ( String name , MonetaryAmount price ) implements Product { } Using your IDE or a command line, run the maven test and check the resulting output. mvn clean test Did it work? Why did the price was correctly calculated even though we didn't add new business logic to the order?","title":"Adding the beverage model"},{"location":"03_action/#congratulations","text":"You've done a great job so far. Let's keep on adding new concepts and technologies to our exercises.","title":"Congratulations!"}]}